<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üè• Vet Clinic Display - TV Compatible</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* TV-optimized styles */
    body {
      overflow: hidden;
      cursor: none;
    }
    
    .tv-controls {
      position: fixed;
      top: 4px;
      right: 4px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.4rem;
      border-radius: 3px;
      font-size: 0.6rem;
      z-index: 900;
    }
    
    .connection-status {
      position: fixed;
      bottom: 5px;
      left: 5px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.3rem 0.5rem;
      border-radius: 3px;
      font-size: 0.6rem;
      z-index: 1000;
    }
    
    .status-online { background: rgba(72, 187, 120, 0.9) !important; }
    .status-offline { background: rgba(229, 62, 62, 0.9) !important; }
    .status-loading { background: rgba(66, 153, 225, 0.9) !important; }
    
    /* Enhanced TV display - No scrolling, compact grid layout */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    
    #app {
      height: 100vh;
      padding: 0;
      margin: 0;
      /* Account for fixed controls */
      box-sizing: border-box;
    }
    
    .display-screen { 
      height: 100%;
      padding: 0.1rem;
      display: grid;
      grid-template-columns: 3fr 1fr; /* Rooms take 3/4, lobby takes 1/4 */
      grid-template-rows: auto auto 1fr;
      gap: 0.2rem;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    .display-screen h1 { 
      grid-column: 1 / -1; /* Span full width */
      font-size: clamp(1rem, 2.5vw, 1.5rem) !important; 
      margin: 0 !important;
      text-align: center;
      flex-shrink: 0;
    }
    
    .display-time {
      grid-column: 1 / -1; /* Span full width */
      font-size: clamp(0.7rem, 1.8vw, 1rem) !important;
      margin: 0 !important;
      text-align: center;
      flex-shrink: 0;
    }
    
    .rooms-display-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* 3 columns */
      grid-template-rows: repeat(2, 1fr); /* 2 rows */
      gap: 0.2rem;
      min-height: 0;
    }
    
    .display-room-card { 
      padding: 0.2rem !important;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
      width: 100%;
      height: 100%;
      border: 3px solid;
    }
    
    /* Status-based border colors for room cards */
    .display-room-card.empty {
      border-color: #718096;
    }
    
    .display-room-card.status-waiting_room {
      border-color: #48bb78; /* Green for waiting in room */
    }
    
    .display-room-card.status-dr_assigned {
      border-color: #c084fc; /* Purple for doctor assigned */
    }
    
    .display-room-card h2 { 
      font-size: clamp(1rem, 2.5vw, 1.5rem) !important; /* Reduced from 3x */
      margin: 0 0 0.1rem 0 !important;
      text-align: center;
      flex-shrink: 0;
    }
    
    .display-visitor {
      flex: 1;
      min-height: 0;
      overflow: hidden;
      text-align: center;
    }
    
    .pet-name { 
      font-size: clamp(0.8rem, 2vw, 1.2rem) !important; /* Reduced from 3x */
      margin: 0.04rem 0 !important;
      line-height: 1.1;
    }
    
    .owner-name { 
      font-size: clamp(0.7rem, 1.8vw, 1rem) !important; /* Reduced from 3x */
      margin: 0.04rem 0 !important;
      line-height: 1.1;
    }
    
    .arrival-time {
      font-size: clamp(0.6rem, 1.6vw, 0.9rem) !important;
      margin: 0.04rem 0 !important;
      line-height: 1.1;
      color: #68d391;
      font-style: italic;
    }
    
    .doctor-name {
      font-size: clamp(0.6rem, 1.6vw, 0.9rem) !important; /* Reduced from 3x */
      margin: 0.04rem 0 !important;
      line-height: 1.1;
    }
    
    .status-display {
      font-size: clamp(0.5rem, 1.4vw, 0.8rem) !important; /* Reduced from 3x */
      padding: 0.04rem !important;
      margin: 0.04rem 0 !important;
      line-height: 1.1;
    }
    
    .empty-room {
      font-size: clamp(0.7rem, 1.8vw, 1rem) !important; /* Reduced from 3x */
      margin: 0.1rem 0 !important;
      text-align: center;
    }
    
    .lobby-display {
      padding: 0.2rem !important;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }
    
    .lobby-display h2 {
      font-size: clamp(1rem, 2.5vw, 1.5rem) !important; /* Reduced from 3x */
      margin: 0 0 0.1rem 0 !important;
      text-align: center;
      flex-shrink: 0;
    }
    
    .lobby-visitors {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      overflow-y: auto;
      /* Custom scrollbar for better TV display */
      scrollbar-width: thin;
    }
    
    .lobby-visitors::-webkit-scrollbar {
      width: 3px;
    }
    
    .lobby-visitors::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .lobby-visitors::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
    }
    
    .lobby-visitor {
      padding: 0.1rem !important;
      font-size: clamp(0.6rem, 1.6vw, 0.9rem) !important; /* Reduced from 3x */
      line-height: 1.1;
      display: flex;
      flex-direction: column;
      text-align: center;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
      overflow: hidden;
      flex-shrink: 0;
    }
    
    .lobby-visitor-name {
      font-weight: bold;
      margin-bottom: 0.04rem;
    }
    
    .lobby-visitor-time {
      opacity: 0.7;
      font-size: 0.9em;
    }
    
    .no-visitors {
      font-size: clamp(0.7rem, 1.8vw, 1rem) !important; /* Reduced from 3x */
      margin: 0 !important;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    
    .lobby-overflow {
      font-size: clamp(0.5rem, 1.4vw, 0.8rem) !important; /* Reduced from 3x */
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      padding: 0.1rem;
      color: #ffd700;
      flex-shrink: 0;
    }
    
    .error-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(229, 62, 62, 0.9);
      color: white;
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      z-index: 2000;
    }
    
    /* Stats Panel for TV Display */
    .stats-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #4a5568;
      border-radius: 12px;
      padding: 0.8rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      min-width: 180px;
      z-index: 1000;
      color: #f7fafc;
    }

    .stats-panel h3 {
      margin: 0 0 0.4rem 0;
      color: #f7fafc;
      font-size: 0.9rem;
      text-align: center;
      border-bottom: 1px solid #4a5568;
      padding-bottom: 0.4rem;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.2rem 0;
      font-size: 0.75rem;
    }

    .stats-label {
      color: #a0aec0;
    }

    .stats-value {
      font-weight: bold;
      color: #f7fafc;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
    }

    .auto-refresh-indicator {
      text-align: center;
      font-size: 0.65rem;
      color: #68d391;
      margin-top: 0.4rem;
      padding-top: 0.4rem;
      border-top: 1px solid #4a5568;
    }
    
    /* Updated color scheme for doctor assigned status */
    .status-display.dr_assigned {
      background: rgba(233, 213, 255, 0.3);
      color: #c084fc;
    }
    
    .doctor-name {
      color: #c084fc !important;
    }

    /* Minimizable Stats Panel for TV */
    .stats-panel.minimized .stats-content {
      display: none;
    }

    .stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 0.25rem 0;
      user-select: none;
      transition: background-color 0.2s ease;
    }

    .stats-header:hover {
      background-color: rgba(241, 245, 249, 0.8);
      border-radius: 6px;
      padding: 0.25rem 0.5rem;
    }

    .stats-title {
      font-weight: bold;
      color: #2d3748;
      font-size: 0.8rem;
    }

    .stats-summary {
      font-size: 0.6rem;
      color: #68d391;
      margin-left: 0.5rem;
    }

    .toggle-icon {
      font-size: 0.7rem;
      color: #4a5568;
      transition: transform 0.2s ease;
    }

    .stats-content {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid #e2e8f0;
    }

    /* TV-specific stats adjustments */
    .stats-panel {
      font-size: 0.75rem !important;
    }

    .stats-item {
      margin: 0.15rem 0 !important;
    }
  </style>
</head>
<body>
  <div class="tv-controls">
    <div>üîÑ Auto-refresh: <span id="refreshTimer">3</span>s</div>
    <div>üì∫ TV Display Mode</div>
    <div>üåê Status: <span id="apiStatus">Connecting...</span></div>
  </div>
  
  <div class="connection-status status-loading" id="connectionStatus">
    üîÑ Connecting to dashboard...
  </div>
  
  <div id="app">
    <div class="display-screen">
      <h1>üè• Vet Clinic Room Status</h1>
      <div class="display-time">Loading...</div>
      <div class="rooms-display-grid">
        <div class="display-room-card empty">
          <h2>Loading...</h2>
          <p class="empty-room">Connecting to server...</p>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // TV-compatible dashboard with better error handling
    let refreshTimer = 3;
    let visitors = [];
    let previousVisitorCount = 0;
    let previousVisitorState = []; // Track visitor states for movement detection
    let isOnline = false;
    let statsExpanded = false; // Track stats panel state
    
    // Global audio context for Fire TV compatibility
    let audioContext = null;
    let audioEnabled = false;
    
    // Initialize audio context on user interaction (required for Fire TV)
    function initializeAudio() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          audioEnabled = true;
          updateAudioStatus('Ready');
          console.log('üîä Audio context initialized for Fire TV');
        } catch (error) {
          updateAudioStatus('Failed');
          console.warn('üîá Could not initialize audio context:', error);
        }
      }
    }
    
    // Update audio status indicator
    function updateAudioStatus(status) {
      const audioStatus = document.getElementById('audioStatus');
      if (audioStatus) {
        audioStatus.textContent = status;
      }
    }
    
    // Sound notification function for TV display - Fire TV compatible
    function playNotificationSound() {
      // Initialize audio context if not already done
      if (!audioContext) {
        initializeAudio();
      }
      
      // Method 1: Try Web Audio API (preferred)
      if (audioContext && audioEnabled) {
        try {
          // Resume context if suspended (common on Fire TV)
          if (audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          // Create oscillator with Fire TV optimized settings
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Fire TV works better with specific frequencies
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Louder for TV
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
          
          console.log('üîä Fire TV notification sound played (Web Audio)');
          return; // Success, exit function
        } catch (error) {
          console.warn('üîá Web Audio API failed on Fire TV:', error);
        }
      }
      
      // Method 2: HTML5 Audio fallback for Fire TV
      try {
        // Create a data URL with a simple audio tone
        const audioData = createAudioDataURL();
        const audio = new Audio(audioData);
        audio.volume = 0.5;
        audio.play().then(() => {
          console.log('üîä Fire TV notification sound played (HTML5 Audio)');
        }).catch(error => {
          console.warn('üîá HTML5 Audio failed on Fire TV:', error);
          // Method 3: Visual notification fallback
          showVisualNotification();
        });
      } catch (error) {
        console.warn('üîá HTML5 Audio creation failed:', error);
        // Method 3: Visual notification fallback
        showVisualNotification();
      }
    }
    
    // Create a simple audio data URL (works better on Fire TV)
    function createAudioDataURL() {
      // Create a simple WAV file data URL for better Fire TV compatibility
      const sampleRate = 22050;
      const duration = 0.5;
      const frequency = 800;
      const samples = Math.floor(sampleRate * duration);
      
      // Create WAV header
      const buffer = new ArrayBuffer(44 + samples * 2);
      const view = new DataView(buffer);
      
      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + samples * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, samples * 2, true);
      
      // Generate sine wave samples
      for (let i = 0; i < samples; i++) {
        const t = i / sampleRate;
        const amplitude = Math.sin(2 * Math.PI * frequency * t) * 0.3;
        const sample = Math.max(-1, Math.min(1, amplitude));
        view.setInt16(44 + i * 2, sample * 0x7fff, true);
      }
      
      // Convert to data URL
      const blob = new Blob([buffer], { type: 'audio/wav' });
      return URL.createObjectURL(blob);
    }
    
    // Visual notification fallback for Fire TV
    function showVisualNotification() {
      console.log('ÔøΩ Showing visual notification (audio not available)');
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 193, 7, 0.95);
        color: #000;
        padding: 2rem 3rem;
        border-radius: 20px;
        font-size: 2rem;
        font-weight: bold;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        animation: pulse 0.5s ease-in-out;
      `;
      notification.innerHTML = 'üîî UPDATE!';
      
      // Add pulse animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
          50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Remove after 2 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
        if (style.parentNode) {
          style.parentNode.removeChild(style);
        }
      }, 2000);
    }
    
    // Create a unique state signature for each visitor to detect changes
    function createVisitorStateSignature(visitors) {
      return visitors.map(v => ({
        id: v.id,
        room: v.room,
        status: v.status,
        tech: v.tech || '',
        doctor: v.doctor || ''
      }));
    }
    
    // Check if visitors have moved or changed status
    function detectVisitorChanges(newVisitors, oldState) {
      const newState = createVisitorStateSignature(newVisitors);
      
      // If this is the first load, don't trigger sounds
      if (oldState.length === 0) {
        return { hasNewVisitors: false, hasMovements: false };
      }
      
      // Check for new visitors (new IDs)
      const oldIds = oldState.map(v => v.id);
      const newIds = newState.map(v => v.id);
      const hasNewVisitors = newIds.some(id => !oldIds.includes(id));
      
      // Check for movements/changes in existing visitors
      let hasMovements = false;
      for (const newVisitor of newState) {
        const oldVisitor = oldState.find(v => v.id === newVisitor.id);
        if (oldVisitor) {
          // Check if room, status, tech, or doctor changed
          if (oldVisitor.room !== newVisitor.room || 
              oldVisitor.status !== newVisitor.status ||
              oldVisitor.tech !== newVisitor.tech ||
              oldVisitor.doctor !== newVisitor.doctor) {
            hasMovements = true;
            break;
          }
        }
      }
      
      return { hasNewVisitors, hasMovements };
    }
    
    // Simple XHR function for better TV browser compatibility
    function fetchData(url, callback, errorCallback) {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.timeout = 10000; // 10 second timeout
      
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            try {
              const data = JSON.parse(xhr.responseText);
              callback(data);
            } catch (e) {
              console.error('Parse error:', e);
              errorCallback('Invalid data format');
            }
          } else {
            errorCallback('Server error: ' + xhr.status);
          }
        }
      };
      
      xhr.onerror = function() {
        errorCallback('Network error');
      };
      
      xhr.ontimeout = function() {
        errorCallback('Request timeout');
      };
      
      xhr.send();
    }
    
    // Load visitors from API
    function loadVisitors() {
      updateStatus('loading', 'üîÑ Loading data...');
      
      fetchData('/api/visitors', 
        function(data) {
          // Success
          const newVisitors = data || [];
          
          // Detect changes and play appropriate sounds
          const changes = detectVisitorChanges(newVisitors, previousVisitorState);
          
          if (changes.hasNewVisitors) {
            console.log('üîä New visitor detected, playing notification sound');
            playNotificationSound();
          } else if (changes.hasMovements) {
            console.log('üîä Visitor movement/change detected, playing notification sound');
            playNotificationSound();
          }
          
          visitors = newVisitors;
          previousVisitorCount = visitors.length;
          previousVisitorState = createVisitorStateSignature(visitors);
          isOnline = true;
          updateStatus('online', 'üü¢ Connected');
          updateDisplay();
          console.log('‚úÖ Loaded', visitors.length, 'visitors from API');
          
          // Sync to localStorage for backup
          try {
            localStorage.setItem('visitors', JSON.stringify(visitors));
          } catch (e) {
            console.warn('Could not save to localStorage:', e);
          }
        },
        function(error) {
          // Error - try localStorage fallback
          console.warn('API failed:', error);
          try {
            const localData = localStorage.getItem('visitors');
            const newVisitors = localData ? JSON.parse(localData) : [];
            
            // Initialize visitor state on first load
            if (previousVisitorState.length === 0) {
              previousVisitorState = createVisitorStateSignature(newVisitors);
              previousVisitorCount = newVisitors.length;
            }
            
            visitors = newVisitors;
            isOnline = false;
            updateStatus('offline', 'üü° Using local data (' + visitors.length + ')');
            updateDisplay();
            console.log('üì± Using localStorage:', visitors.length, 'visitors');
          } catch (e) {
            console.error('localStorage failed too:', e);
            visitors = [];
            updateStatus('offline', 'üî¥ No data available');
            showError('Cannot connect to dashboard server');
          }
        }
      );
    }
    
    // Update connection status
    function updateStatus(type, message) {
      const status = document.getElementById('connectionStatus');
      const apiStatus = document.getElementById('apiStatus');
      
      status.className = 'connection-status status-' + type;
      status.textContent = message;
      apiStatus.textContent = type === 'online' ? 'API' : type === 'offline' ? 'Local' : 'Loading';
    }
    
    // Show error message
    function showError(message) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.innerHTML = `
        <h2>‚ö†Ô∏è Connection Error</h2>
        <p>${message}</p>
        <p><small>Retrying in ${refreshTimer} seconds...</small></p>
      `;
      document.body.appendChild(errorDiv);
      
      setTimeout(() => {
        if (errorDiv.parentNode) {
          errorDiv.parentNode.removeChild(errorDiv);
        }
      }, 3000);
    }
    
    // Update the display
    function updateDisplay() {
      const app = document.getElementById('app');
      
      // Use the same time format as the admin side, but subtract 1 hour
      const now = new Date();
      now.setHours(now.getHours() - 1); // Subtract 1 hour
      const currentTime = now.toLocaleString('en-US', { 
        weekday: 'short',
        month: 'short', 
        day: 'numeric', 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true,
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      });
      
      app.innerHTML = `
        <div class="display-screen">
          <h1>üè• Vet Clinic Room Status</h1>
          <div class="display-time">${currentTime}</div>
          
          <div class="rooms-display-grid">
            ${[1, 2, 3, 4, 5, 6].map(roomNum => {
              const roomVisitors = visitors.filter(v => v.room == roomNum);
              const isEmpty = roomVisitors.length === 0;
              
              // Determine room status based on visitors
              let roomStatus = 'empty';
              if (!isEmpty) {
                // Check if any visitor has doctor assigned
                const hasDoctorAssigned = roomVisitors.some(v => v.status === 'dr_assigned');
                roomStatus = hasDoctorAssigned ? 'status-dr_assigned' : 'status-waiting_room';
              }
              
              return `
                <div class="display-room-card ${roomStatus}">
                  <h2>Room ${roomNum}</h2>
                  ${isEmpty ? 
                    '<p class="empty-room">Available</p>' : 
                    roomVisitors.map(visitor => `
                      <div class="display-visitor">
                        <p class="pet-name">üêæ ${visitor.petName}</p>
                        <p class="owner-name">üë§ ${visitor.ownerName}</p>
                        <p class="arrival-time">‚è∞ Arrived: ${visitor.timestamp}</p>
                        <p class="status-display ${visitor.status}">${getDisplayStatus(visitor)}</p>
                        ${visitor.tech ? `<p class="tech-name">üîß Tech: ${visitor.tech}</p>` : ''}
                        ${visitor.doctor ? `<p class="doctor-name">üë©‚Äç‚öïÔ∏è Dr. ${visitor.doctor}</p>` : ''}
                      </div>
                    `).join('')
                  }
                </div>
              `;
            }).join('')}
          </div>
          
          <div class="lobby-display">
            <h2>ü™ë Lobby</h2>
            <div class="lobby-visitors">
              ${(() => {
                const lobbyVisitors = visitors.filter(v => v.room === "lobby");
                if (lobbyVisitors.length === 0) {
                  return '<div class="no-visitors">No one waiting in lobby</div>';
                }
                
                // Show all visitors in a scrollable list
                let html = lobbyVisitors.map(visitor => `
                  <div class="lobby-visitor">
                    <div class="lobby-visitor-name">üêæ ${visitor.petName}</div>
                    <div class="lobby-visitor-time">‚è∞ Arrived: ${visitor.timestamp}</div>
                  </div>
                `).join('');
                
                return html;
              })()}
            </div>
          </div>
        </div>
      `;
      
      // Add stats panel
      updateStatsPanel();
    }
    
    // Generate and update stats panel
    function updateStatsPanel() {
      // Remove existing stats panel
      const existingStatsPanel = document.querySelector('.stats-panel');
      if (existingStatsPanel) {
        existingStatsPanel.remove();
      }
      
      // Generate stats
      const totalVisitors = visitors.length;
      const lobbyCount = visitors.filter(v => v.room === "lobby").length;
      const roomCount = visitors.filter(v => v.room !== "lobby").length;
      const techAssigned = visitors.filter(v => v.tech).length;
      const doctorAssigned = visitors.filter(v => v.doctor).length;
      const bothAssigned = visitors.filter(v => v.tech && v.doctor).length;
      
      // Use the current state to determine if panel should be expanded
      const panelClass = statsExpanded ? 'stats-panel' : 'stats-panel minimized';
      const contentDisplay = statsExpanded ? 'block' : 'none';
      const toggleIcon = statsExpanded ? '‚ñº' : '‚ñ∂';
      
      const statsHTML = `
        <div class="${panelClass}" id="statsPanel">
          <div class="stats-header" onclick="toggleStatsPanel()">
            <span class="stats-title">üìä Dashboard Stats</span>
            <span class="stats-summary">(${totalVisitors} total)</span>
            <span class="toggle-icon">${toggleIcon}</span>
          </div>
          <div class="stats-content" id="statsContent" style="display: ${contentDisplay};">
            <div class="stats-item">
              <span class="stats-label">Total Visitors:</span>
              <span class="stats-value">${totalVisitors}</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">In Lobby:</span>
              <span class="stats-value">${lobbyCount}</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">In Rooms:</span>
              <span class="stats-value">${roomCount}</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">With Tech:</span>
              <span class="stats-value">${techAssigned}</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">With Doctor:</span>
              <span class="stats-value">${doctorAssigned}</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Tech + Doctor:</span>
              <span class="stats-value">${bothAssigned}</span>
            </div>
            <div class="auto-refresh-indicator">
              üîÑ Auto-refresh active
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', statsHTML);
    }
    
    // Toggle stats panel
    function toggleStatsPanel() {
      const panel = document.getElementById('statsPanel');
      const content = document.getElementById('statsContent');
      const icon = panel.querySelector('.toggle-icon');
      
      if (panel.classList.contains('minimized')) {
        panel.classList.remove('minimized');
        content.style.display = 'block';
        icon.textContent = '‚ñº';
        statsExpanded = true; // Update global state
      } else {
        panel.classList.add('minimized');
        content.style.display = 'none';
        icon.textContent = '‚ñ∂';
        statsExpanded = false; // Update global state
      }
    }

    // Get status text
    function getStatusText(status) {
      switch(status) {
        case "waiting_lobby": return "üìã Waiting in Lobby";
        case "waiting_room": return "üö™ Waiting in Room";
        case "tech_assigned": return "üîß Tech Assigned";
        case "dr_assigned": return "üë©‚Äç‚öïÔ∏è Doctor Assigned";
        default: return status;
      }
    }

    // Get display status based on tech and doctor assignments
    function getDisplayStatus(visitor) {
      if (visitor.status === "waiting_lobby") {
        return "üìã Waiting in Lobby";
      }
      
      if (visitor.status === "waiting_room" && !visitor.tech && !visitor.doctor) {
        return "üö™ Waiting in Room";
      }
      
      // Build status based on assignments
      let statusParts = [];
      if (visitor.tech) statusParts.push("üîß Tech");
      if (visitor.doctor) statusParts.push("üë©‚Äç‚öïÔ∏è Doctor");
      
      if (statusParts.length > 0) {
        return statusParts.join(" + ") + " Assigned";
      }
      
      return getStatusText(visitor.status);
    }
    
    // Timer function
    function updateTimer() {
      document.getElementById('refreshTimer').textContent = refreshTimer;
      refreshTimer--;
      
      if (refreshTimer < 0) {
        loadVisitors();
        refreshTimer = 3; // Refresh every 3 seconds
      }
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.key === 'r' || e.key === 'R') {
        loadVisitors();
        refreshTimer = 3;
      }
      if (e.key === 'Escape') {
        window.location.href = 'index.html';
      }
      // Test sound with 't' key
      if (e.key === 't' || e.key === 'T') {
        console.log('üîä Testing sound manually...');
        playNotificationSound();
      }
    });
    
    // Initialize
    console.log('üè• TV Dashboard starting...');
    
    // Initialize visitor state from localStorage to avoid false notifications on startup
    try {
      const localData = localStorage.getItem('visitors');
      if (localData) {
        const localVisitors = JSON.parse(localData);
        previousVisitorCount = localVisitors.length;
        previousVisitorState = createVisitorStateSignature(localVisitors);
        console.log('üìä Initialized with', previousVisitorCount, 'visitors from localStorage');
      }
    } catch (e) {
      console.warn('Could not read localStorage on startup:', e);
    }
    
    // Initialize audio on any user interaction (required for Fire TV)
    const enableAudio = () => {
      initializeAudio();
      document.removeEventListener('click', enableAudio);
      document.removeEventListener('keydown', enableAudio);
      document.removeEventListener('touchstart', enableAudio);
    };
    document.addEventListener('click', enableAudio);
    document.addEventListener('keydown', enableAudio);
    document.addEventListener('touchstart', enableAudio);
    
    // Set initial audio status
    updateAudioStatus('Waiting for interaction');
    
    // Auto-initialize audio after a delay (some Fire TV browsers allow this)
    setTimeout(() => {
      if (!audioEnabled) {
        initializeAudio();
      }
    }, 2000);
    
    loadVisitors();
    setInterval(updateTimer, 1000);
    
    // Auto-hide cursor
    let cursorTimeout;
    function hideCursor() {
      document.body.style.cursor = 'none';
    }
    function showCursor() {
      document.body.style.cursor = 'default';
      clearTimeout(cursorTimeout);
      cursorTimeout = setTimeout(hideCursor, 3000);
    }
    document.addEventListener('mousemove', showCursor);
    showCursor();
  </script>
</body>
</html>
